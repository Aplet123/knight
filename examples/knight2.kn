## Peeks at the first character in the stream.
# ARGUMENTS:
#    __stream: The stream to peek into.
# RETURNS:
#    the first character of the string, or an empty string if the stream's empty.
# CLOBBERS:
#    __chr: the return value is also assigned to `__chr`.
; = peek BLOCK
	: = __chr GET __stream 0 1

## Discards the first character of the stream.
# ARGUMENTS:
#    __stream: The stream to delete the first character of
; = advance BLOCK
	: = __stream SET __stream 0 1 ""

## Checks to see if the stream is at end of file.
# ARGUMENTS:
#    __stream: The stream to check.
# RETURNS:
#    True if the stream is empty, false otherwise.
; = iseof BLOCK
	: ! LENGTH __stream

## Checks to see if the given character is a digit.
# ARGUMENTS:
#    __chr: The character to check
# RETURNS:
#    True when the character is a single ASCII digit; false otherwise.
; = isdigit BLOCK 
	: & (< '/' __chr) (> ':' __chr)

## Checks to see if the given character is whitespace.
# ARGUMENTS:
#    __chr: The character to check
# RETURNS:
#    True when the character is a newline, tab, or a space; false otherwise.
; = iswhitespace BLOCK
	: | (CALL iseol)
	  | (? __chr ' ')
	  | (? __chr '	')
	  | (? __chr '(')
	  | (? __chr ')')
	  | (? __chr '[')
	  | (? __chr ']')
	  | (? __chr '{')
	  | (? __chr '}')
	    (? __chr ':')

## Checks to see if the given character is a lowercase character or an underscore.
# ARGUMENTS:
#    __chr: The character to check
# RETURNS:
#    True if the character is between `a` and `z`, or is equal to `_`.
; = islower BLOCK
	:  | (& (< '`' __chr) (> '{' __chr)) (? '_' __chr)

## Checks to see if the given character is an uppercase character.
# ARGUMENTS:
#    __chr: The character to check
# RETURNS:
#    True if the character is between `A` and `Z`
; = isupper BLOCK
	:  & (< '@' __chr) (> '[' __chr)

## Checks to see if the given character is an end of line character.
# ARGUMENTS:
#    __chr: The character to check
# RETURNS:
#    True if the character is a literal newline.
; = iseol BLOCK
	: ? __chr '
'

## Strips all leading whitespace and comments from the stream.
# ARGUMENTS:
#    __stream: The stream to strip.
# CLOBBERS:
#    __chr: The `__chr` character is clobbered in this function.
; = strip_whitespace_and_comments BLOCK
	; CALL peek
	: IF CALL iswhitespace
		; CALL advance
		: CALL strip_whitespace_and_comments
	: IF (? __chr '#')
		; CALL advance
		; WHILE ! | (CALL iseof) (CALL iseol)
			; CALL advance
			: CALL peek
		: CALL strip_whitespace_and_comments
		: NULL

; = __next_number BLOCK
	; = __next_number_ret 0
	; WHILE CALL isdigit
		; = __next_number_ret + * 10 __next_number_ret __chr
		; CALL peek
		: CALL advance
	: __next_number_ret

; = __next_identifier BLOCK
	; = __next_identifier_ret 'i'
	; WHILE | (CALL islower) (CALL isdigit)
		; = __next_identifier_ret + __next_identifier_ret __chr
		; CALL peek
		: CALL advance
	: __next_identifier_ret

; = __next_string BLOCK
	; = __next_string_quote __chr
	; = __next_string_ret 's'
	; CALL peek
	; WHILE ! | (CALL iseol) (? __chr __next_string_quote)
		; = __next_string_ret + __next_string_ret __chr
		; CALL advance
		: CALL peek
	; IF (CALL iseol)
		; OUTPUT ++ "unterminated quote: " __next_string_quote __next_string_ret
		: QUIT 1
		: CALL advance # remove trailing quote, if one exists
	: __next_string_ret

; = __next_function BLOCK
	; = __next_function_ret __chr
	; IF CALL isupper
		; CALL peek
		: WHILE (CALL isupper)
			; CALL advance
			: CALL peek
		: N
	: IF | (? __next_function_ret 'T')
	     | (? __next_function_ret 'F')
	     | (? __next_function_ret 'N')
	     | (? __next_function_ret 'P')
	       (? __next_function_ret 'R')
		: + __next_function_ret '$'
		: IF | (? __next_function_ret 'B')
		     | (? __next_function_ret 'E')
		     | (? __next_function_ret 'C')
		     | (? __next_function_ret '`')
		     | (? __next_function_ret 'Q')
		     | (? __next_function_ret '!')
		     | (? __next_function_ret 'L')
		       (? __next_function_ret 'O')
		  : +++ __next_function_ret ',' (CALL next_ast) '$'
			: IF | (? __next_function_ret '+')
			     | (? __next_function_ret '-')
			     | (? __next_function_ret '*')
			     | (? __next_function_ret '/')
			     | (? __next_function_ret '%')
			     | (? __next_function_ret '^')
			     | (? __next_function_ret '?')
			     | (? __next_function_ret '<')
			     | (? __next_function_ret '>')
			     | (? __next_function_ret ';')
			     | (? __next_function_ret '=')
			     | (? __next_function_ret 'W')
			     | (? __next_function_ret '&')
			       (? __next_function_ret '|')
			  : +++++ __next_function_ret ',' (CALL next_ast) ',' (CALL next_ast) '$'
				: IF | (? __next_function_ret 'I')
				       (? __next_function_ret 'G')
				  : +++++++ __next_function_ret ',' (CALL next_ast) ',' (CALL next_ast) ',' (CALL next_ast) '$'
					: IF (? __next_function_ret 'S')
					  : +++++++++ __next_function_ret ',' (CALL next_ast) ',' (CALL next_ast) ',' (CALL next_ast) ',' (CALL next_ast) '$'
					  ; OUTPUT ++ "unknown function '" __next_function_ret "'."
					  : QUIT 1

# Actually parse the AST
; = __next_ast BLOCK
	; CALL strip_whitespace_and_comments
	; CALL peek
	; CALL advance
	: IF CALL isdigit
		: CALL __next_number
		: IF CALL islower
			: CALL __next_identifier
			: IF | (? __chr '"') (? __chr "'")
				: CALL __next_string
				: CALL __next_function

# Assign the AST a unique name and return that name.
; = __next_function_idx 0
; = __next_ast_recur 0
; = next_ast BLOCK
	; = (+ '__next_ast_name_' __next_ast_recur) (+ "__ast_fn_" __next_function_idx)
	; = __next_function_idx + __next_function_idx 1
	; = __next_ast_recur + __next_ast_recur 1
	; = __next_ast_tmp CALL __next_ast
	; = __next_ast_recur - __next_ast_recur 1
	; = __next_ast_name (EVAL + "__next_ast_name_" __next_ast_recur)
	; = (+ "" __next_ast_name) __next_ast_tmp
	: __next_ast_name

; = __stream ' 	# FOO
; = a 3 : O + "a*3=" * a 3'
; OUTPUT + +'"'CALL next_ast'"'
; OUTPUT ++'__ast_fn_0: "'__ast_fn_0'"'
; OUTPUT ++'__ast_fn_1: "'__ast_fn_1'"'
; OUTPUT ++'__ast_fn_2: "'__ast_fn_2'"'
; OUTPUT ++'__ast_fn_3: "'__ast_fn_3'"'
; OUTPUT ++'__ast_fn_4: "'__ast_fn_4'"'
; OUTPUT ++'__ast_fn_5: "'__ast_fn_5'"'
; OUTPUT ++'__ast_fn_6: "'__ast_fn_6'"'
; OUTPUT ++'__ast_fn_7: "'__ast_fn_7'"'
; OUTPUT ++'__ast_fn_8: "'__ast_fn_8'"'
; OUTPUT ++'__ast_fn_9: "'__ast_fn_9'"'
: N



# 
# ; = next_token BLOCK
# 	; CALL strip_whitespace_and_comments
# 	; CALL peek
# 	; CALL advance
# 	; = __next_token_ret __chr
# 
# 	: IF CALL isdigit
# 		; WHILE CALL isdigit
# 			; = __next_token_ret + __next_token_ret __chr
# 			: CALL advance
# 		: + 0 __next_token_ret
# 	: IF CALL islower
# 		; WHILE | (CALL islower) (CALL isdigit)
# 			; = __next_token_ret + __next_token_ret __chr
# 			: CALL advance
# 		: + 0 __next_token_ret
# 	: IF | (? __chr '"') (? __chr "'")
# 		NULL
# 		NULL
# 
# 
# 
# ; = stream "; = a 3 : OUT + 'a*4=' * a 4"
# 
# ; = __stream "   
# # A 123
# 1234"
# : OUTPUT CALL next_token
